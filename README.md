# fucking-front-end
一些自己找到的好的知识点学习链接

# javascript

### 原型与原型链
这一个部分主要是记住这一张图  
<img width="548" alt="截屏2021-11-17 下午2 21 44" src="https://user-images.githubusercontent.com/37279552/142145786-32f6d788-d0eb-4b69-ba76-56956b59d9ad.png">  
以及另外一个重要的知识点：Function.__proto__ = Function.prototype.  
对于这个点的理解是：Function作为一个内置对象，是本身就已经有的，因为它本身又是一个对象，为了与其他对象保持一致，所以就有了上述的关系，但是不能说因为有上述关系，就说Function调用自己，自己生成自己。

### 词法作用域与动态作用域
javascript采用的是此法作用域，这是一种静态作用域，**静态作用域是指函数的作用域在函数定义时就决定了**。与之对应的动态作用域是指**函数的作用域在函数调用时决定**。  
下面这段代码可以很好地用来诠释静态作用域特点所起到的作用
```
  var value = 1;
  function foo() {
    console.log(value);
  }
  function bar() {
    var value = 2;
    foo();
  }
  bar();
```
因为javascript的静态作用域特性使函数的作用域在定义时就决定了，那foo这个函数是在什么时候被定义的呢？那就是在全局下面，所以对于foo来说，他如果要查找value这个变量，首先会查找函数内部，如果没有这个变量，就会到函数的外部环境中查找，也就是全局作用域中进行查找，所以找到的value为1.而如果是动态作用域，在调用时决定其作用域，此时打印的value为2.

### 模块化
[搞懂javascript模块化](https://juejin.cn/post/6844903636108066830#comment)  
一些关键点：  

演变过程：无模块化--commonJS--AMD--CMD--ES6 Module.     

无模块化的时候，这些变量都是直接挂载在window上，容易污染全局作用域，而且模块与模块之间的依赖并不清晰，如果一个文件需要引入A模块，而A模块又引入了B模块，那就必须要先引入B模块，再引入A模块才能正常。

commonJS是一种服务端的模块化标准。采用module.exports方式导出模块，require的方式导入模块。exports是module.exports的一个引用，或者说exports是一个指针，和module.exports指向同一块地址，因此如果直接给exports赋值，相当于使exports指向了一块其他的地址。commonJS采用**同步的方式加载模块**,因为他本身是一种服务端的规范，而服务端的数据都是存储在本地的，读取都非常快，所以该规范应用在服务端的话会很顺畅。但是应用在客户端，由于实时性并不好，所以其不能支持异步加载也成为了其缺陷。  

AMD和CMD使用require引入模块，使用define定义模块，他们使用**异步方式加载模块**。AMD与CMD的区别在于CMD实现了按需加载，AMD提倡的是**依赖前置**，require和define的第一个参数可以是数组，里面是他们的依赖，所以在AMD中会在执行模块内容之前预先加载好模块依赖的其他模块，但是在CMD中，会在执行模块代码的过程中，遇到其需要加载其他模块的时候，再去加载对应模块，实现**按需加载**。 

ES6module的加载分成三个部分，他首先会在程序开始前根据模块关系找到所有模块，然后形成一个无环的模块关系表，然后把所有模块实例建好，这样其实就已经能够避免循环引用了，同时在ES6module里面也是存在cache的，即重复import同一个模块，只执行一次代码。在第二步中，会在内存中腾出来一块空间，给那些即将要export出来的东西，import和export就指向这部分内存空间，这部分过程称为连接。在第三部分运行模块时会把生成的值写到第二部分开辟的空间中。而且在ESModle中，如果被export的值被修改了，是会被反映在import里面的，这个功能的实现就是living bound。

ES6module与commonJS的区别在于，ES6module是在编译时加载，比如在文件A中对模块K进行了引入，那在对文件A进行编译时，就会去加载这个模块K，加载的结果是对这个模块的一个引用，而之后在文件中针对这个模块K中的内容进行使用时，会实时地通过这个引用去拿模块内的数据。而commonJS是在运行时加载，且**会在运行之前就被写入cache**，所以如果同一个模块如果被require多次，模块内部只会执行一次，module.exports出来的是同一个对这个模块的引用。同时这种运行之前被写入cache有一个好处是用来解决循环引用，比如文件A引入了模块K，模块K引入了模块M，而模块M又引入了模块K，因为commonJS是同步执行的，所以按顺序在执行到模块M的时候，发现要引入模块K，模块K虽然暂时还没有执行，但是已经能够在内存中查找到，所以模块M在使用模块K中的内容时，拿到的是undefined。而在ESModule中，由于在第二步已经为模块占了坑，但是并没有为这个坑填上值，所以当出现了循环引用时，采用import * as s fron '../M.js'的方式不会报错，打印s会显示模块里面有的东西，但这些东西是没有值的，但是如果使用import {a1, a2} from '../M.js'就会报错，因为不可以在赋值之前使用这些东西。另一个不同点在于commonJS是对整个模块整体进行引入，但是ESModule可以实现按需加载，你需要什么，就引出什么。
[深度好文](https://blog.csdn.net/xgangzai/article/details/106935104)


